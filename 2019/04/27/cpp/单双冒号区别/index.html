<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="damn1t"><meta name="renderer" content="webkit"><meta name="copyright" content="damn1t"><meta name="keywords" content="damn1t"><meta name="description" content="404"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>c++中冒号（:）和双冒号（::）的用法 · Mr.Long's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">longlongyu</div><div class="profile-signature">for me</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Long's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">c++中冒号（:）和双冒号（::）的用法</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019-04-27</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="cpp"> cpp</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="c-中冒号（-）和双冒号（-）的用法"><a href="#c-中冒号（-）和双冒号（-）的用法" class="headerlink" title="c++中冒号（:）和双冒号（::）的用法"></a>c++中冒号（:）和双冒号（::）的用法</h1><p>1.冒号（:）用法</p>
<p>（1）表示机构内位域的定义（即该变量占几个bit空间）</p>
<p>typedef struct _XXX{</p>
<p>unsigned char a:4;</p>
<p>unsigned char c;</p>
<p>} ; XXX</p>
<p>（2）构造函数后面的冒号起分割作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型。</p>
<p>struct _XXX{</p>
<p>_XXX() : y(0xc0) {}</p>
<p>};</p>
<p>（3） public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个”public:”或”private:”出现为止。”private:”为默认处理。</p>
<p>（4）类名冒号后面的是用来定义类的继承。</p>
<p>class 派生类名 : 继承方式 基类名</p>
<p>{</p>
<p>派生类的成员</p>
<p>};</p>
<p>继承方式：public、private和protected，默认处理是public。</p>
<p>2．双冒号（::）用法</p>
<p>（1）表示“域操作符”<br>例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，<br>就要写成void A::f()，表示这个f()函数是类A的成员函数。</p>
<p>（2）直接用在全局函数前，表示是全局函数<br>例：在VC里，你可以在调用API 函数里，在API函数名前加：：</p>
<p>（3）表示引用成员函数及变量，作用域成员运算符</p>
<p>例：System::Math::Sqrt() 相当于System.Math.Sqrt()<br>——————————————————————————————————————</p>
<p>VC中如下</p>
<p>::是C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。<br>　　:: 一般还有一种用法，就是直接用在全局函数前，表示是全局函数。当类的成员函数跟类外的一个全局函数同名时，考试,大提示在类内定义的时候，打此函数名默认调用的是本身的成员函数；如果要调用同名的全局函数时，就必须打上::以示区别。比如在VC里，你可以在调用API函数时，在API函数名前加::。（编辑：）</p>
<hr>
<hr>
<hr>
<p>这篇文章将总结C/C++中的冒号的用法。</p>
<p>1、位域定义<br>这个在前面关于位结构体的文章里说得够多的了，不再重复了。</p>
<p>2、类构造函数(Constructor）的初始化列表<br>先说下什么叫构造函数吧（是不是啰嗦了？C++的人应该都知道了吧，还是以防万一一下）。所谓构造函数，就是与类同名的函数，它与普通函数的区别在于，它没有返回类型。<br>在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号(,)隔开。下面举个例子。<br>class myClass<br>{<br>public :<br>myClass();// 构造函数，无返回类型，可以有参数列表，这里省去<br>~myClass();// 析构函数<br>int a;<br>const int b;<br>}</p>
<p>myClass::myClass():a(1),b(1)// 初始化列表<br>{<br>}<br>上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：<br>1)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。<br>在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错：<br>myClass::myClass（）<br>{<br>a = 1;// 没错，效果相当于在初始化列表中进行初始化<br>b = 1;// 出错，const变量不能进行赋值操作；<br>}<br>2）初始化的顺序与成员变量声名的顺序相同。<br>先看一下下面的程序：<br>myClass::myClass():b(1),a(b)<br>{<br>}<br>这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。<br>3）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。</p>
<p>3、声明基类。<br>假设我们重新定义一个类，继承自myClass类。定义方式如下：<br>class derivedClass : public myClass<br>{<br>// 略去<br>}<br>这里的冒号起到的就是声名基类的作用，在基类类名前面可以加public/private/protected等标签，用于标识继承的类型，也可以省略，省略的话，用class定义的类默认为private，用struct定义的类默认为public，至于具体各个标签有什么区别这里就不说了。<br>与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。</p>
<p>4、条件语句(? :)<br>与?构成条件语句，作用相当于if else，如下；<br>int a,b,c;<br>a=3;<br>b=2;<br>c=a&gt;b?a:b;// 如果a&gt;b成立，则反a赋给c，否则把b赋给c<br>条件语句的结构为：<br>条件表达式?表达式1:表达式2<br>当条件表达式为true时，表达式的值为表达式1的值，否则为表达式2的值。<br>几点说明：<br>1）?:可以嵌套，但不推荐使用（难懂），下面的表达式你能看懂啥意思不？<br>int max = i&gt;j ? i&gt;k ? i : k : j&gt;k ? j : k;<br>脑袋大了吧，呵呵。<br>2）?:具有很低的优先级，这个要注意哦，下面的程序执行结果是啥呢？<br>int i = 3;<br>int j = 2;<br>cout &lt;&lt; i&gt;j?i:j;// 出错，&lt;&lt;比&gt;具有更高的优先级，执行顺序为 ((cout&lt;<i)>j)?i:j,相当于是比较cout&lt;<i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。 cout="" <<="" (i="">j)?i:j;//输出1或0，相当于(cout&lt;&lt;(i&gt;j))作为判决条件，来决定表达式的值为i或j，而cout&lt;&lt;(i&gt;j)，i&gt;j则输出1否则0，然后再将(cout&lt;&lt;(i&gt;j))作为？：的条件，如果cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或j<br>cout &lt;&lt;(i&gt;j?i:j);//i&gt;j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false<br>更多的关于优先级的问题就不说了。</i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。></i)></p>
<p>5、语句标签<br>通常跟goto配合使用，如：<br>step1: a = f1();<br>….<br>goto step1;<br>这种作法也不是很推荐，原因在于它破坏了语句的顺序执行，这样的代价大家应该清楚吧。不过存在即为合理嘛，既然它还存在，肯定还是有它的用处有它的好处的，比如说，多层嵌套的退出（会比break continue直观一点吧），也可以避免重复代码之类之类的</p>
<p>6、switch语句中case后。<br>这个不说了，要是不会的话，我也没话可说了。</p>
<p>7、汇编指令模板<br>这个我也不懂，不班门弄斧了，可以参考一下：<a href="http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html" target="_blank" rel="noopener">http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html</a><br>改天学习一下。</p>
<hr>
<hr>
<hr>
<p>1、<br>作用域符号::的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分<br>如：A,B表示两个类，在A,B中都有成员member。那么<br>A::member就表示类A中的成员member<br>B::member就表示类B中的成员member </p>
<p>2、<br>全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分如： </p>
<p>char zhou; //全局变量 </p>
<p>void sleep（） </p>
<p>｛ </p>
<p>char zhou; //局部变量 </p>
<p>char(局部变量) = char(局部变量) *char(局部变量) ; </p>
<p>::char(全局变量) =::char(全局变量) *char(局部变量); </p>
<p>｝ </p>
<p>3、<br>::是C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如</p>
<pre><code>01  class CA {    
02  public:    
03    int ca_var;    
04    int add(int a, int b);    
05    int add(int a);    
06  };   
07      
08  //那么在实现这个函数时，必须这样书写：    
09  int CA::add(int a, int b)    
10  {    
11    return a + b;    
12  }    
13      
14  //另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如:    
15  int CA::add(int a)    
16  {    
17    return a + ::ca_var;    
18  }   
19      
20  //表示当前类实例中的变量ca_var。
</code></pre><p>转载：<a href="https://blog.csdn.net/zimingjushi/article/details/6549390/" target="_blank" rel="noopener">https://blog.csdn.net/zimingjushi/article/details/6549390/</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://microvorld.com">damn1t</a></p><p> <span>Link:  </span><a href="http://microvorld.com/2019/04/27/cpp/单双冒号区别/">http://microvorld.com/2019/04/27/cpp/单双冒号区别/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/04/29/python/python常见问题/" title="python常见问题"><span>< PreviousPost</span><br><span class="prevTitle">python常见问题</span></a><a class="nextSlogan" href="/2019/04/24/vulnerable/race condition/" title="web条件竞争"><span>NextPost ></span><br><span class="nextTitle">web条件竞争</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-中冒号（-）和双冒号（-）的用法"><span class="toc-number">1.</span> <span class="toc-text">c++中冒号（:）和双冒号（::）的用法</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>