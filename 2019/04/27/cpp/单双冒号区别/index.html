<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="damn1t">
  <!-- Open Graph Data -->
  <meta property="og:title" content="c++中冒号（:）和双冒号（::）的用法"/>
  <meta property="og:description" content="404" />
  <meta property="og:site_name" content="damn1t"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://microvorld.com"/>
  
    <link rel="alternate" href="/atom.xml" title="damn1t" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>damn1t</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">c++中冒号（:）和双冒号（::）的用法</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/microvorld">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<bubbl3@foxmail.com>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By damn1t</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-04-27</span>
            <span class="time">15:24:21</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/cpp/">#cpp</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="c-中冒号（-）和双冒号（-）的用法"><a href="#c-中冒号（-）和双冒号（-）的用法" class="headerlink" title="c++中冒号（:）和双冒号（::）的用法"></a>c++中冒号（:）和双冒号（::）的用法</h1><p>1.冒号（:）用法</p>
<p>（1）表示机构内位域的定义（即该变量占几个bit空间）</p>
<p>typedef struct _XXX{</p>
<p>unsigned char a:4;</p>
<p>unsigned char c;</p>
<p>} ; XXX</p>
<p>（2）构造函数后面的冒号起分割作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型。</p>
<p>struct _XXX{</p>
<p>_XXX() : y(0xc0) {}</p>
<p>};</p>
<p>（3） public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个”public:”或”private:”出现为止。”private:”为默认处理。</p>
<p>（4）类名冒号后面的是用来定义类的继承。</p>
<p>class 派生类名 : 继承方式 基类名</p>
<p>{</p>
<p>派生类的成员</p>
<p>};</p>
<p>继承方式：public、private和protected，默认处理是public。</p>
<p>2．双冒号（::）用法</p>
<p>（1）表示“域操作符”<br>例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，<br>就要写成void A::f()，表示这个f()函数是类A的成员函数。</p>
<p>（2）直接用在全局函数前，表示是全局函数<br>例：在VC里，你可以在调用API 函数里，在API函数名前加：：</p>
<p>（3）表示引用成员函数及变量，作用域成员运算符</p>
<p>例：System::Math::Sqrt() 相当于System.Math.Sqrt()<br>——————————————————————————————————————</p>
<p>VC中如下</p>
<p>::是C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。<br>　　:: 一般还有一种用法，就是直接用在全局函数前，表示是全局函数。当类的成员函数跟类外的一个全局函数同名时，考试,大提示在类内定义的时候，打此函数名默认调用的是本身的成员函数；如果要调用同名的全局函数时，就必须打上::以示区别。比如在VC里，你可以在调用API函数时，在API函数名前加::。（编辑：）</p>
<hr>
<hr>
<hr>
<p>这篇文章将总结C/C++中的冒号的用法。</p>
<p>1、位域定义<br>这个在前面关于位结构体的文章里说得够多的了，不再重复了。</p>
<p>2、类构造函数(Constructor）的初始化列表<br>先说下什么叫构造函数吧（是不是啰嗦了？C++的人应该都知道了吧，还是以防万一一下）。所谓构造函数，就是与类同名的函数，它与普通函数的区别在于，它没有返回类型。<br>在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号(,)隔开。下面举个例子。<br>class myClass<br>{<br>public :<br>myClass();// 构造函数，无返回类型，可以有参数列表，这里省去<br>~myClass();// 析构函数<br>int a;<br>const int b;<br>}</p>
<p>myClass::myClass():a(1),b(1)// 初始化列表<br>{<br>}<br>上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：<br>1)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。<br>在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错：<br>myClass::myClass（）<br>{<br>a = 1;// 没错，效果相当于在初始化列表中进行初始化<br>b = 1;// 出错，const变量不能进行赋值操作；<br>}<br>2）初始化的顺序与成员变量声名的顺序相同。<br>先看一下下面的程序：<br>myClass::myClass():b(1),a(b)<br>{<br>}<br>这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。<br>3）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。</p>
<p>3、声明基类。<br>假设我们重新定义一个类，继承自myClass类。定义方式如下：<br>class derivedClass : public myClass<br>{<br>// 略去<br>}<br>这里的冒号起到的就是声名基类的作用，在基类类名前面可以加public/private/protected等标签，用于标识继承的类型，也可以省略，省略的话，用class定义的类默认为private，用struct定义的类默认为public，至于具体各个标签有什么区别这里就不说了。<br>与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。</p>
<p>4、条件语句(? :)<br>与?构成条件语句，作用相当于if else，如下；<br>int a,b,c;<br>a=3;<br>b=2;<br>c=a&gt;b?a:b;// 如果a&gt;b成立，则反a赋给c，否则把b赋给c<br>条件语句的结构为：<br>条件表达式?表达式1:表达式2<br>当条件表达式为true时，表达式的值为表达式1的值，否则为表达式2的值。<br>几点说明：<br>1）?:可以嵌套，但不推荐使用（难懂），下面的表达式你能看懂啥意思不？<br>int max = i&gt;j ? i&gt;k ? i : k : j&gt;k ? j : k;<br>脑袋大了吧，呵呵。<br>2）?:具有很低的优先级，这个要注意哦，下面的程序执行结果是啥呢？<br>int i = 3;<br>int j = 2;<br>cout &lt;&lt; i&gt;j?i:j;// 出错，&lt;&lt;比&gt;具有更高的优先级，执行顺序为 ((cout&lt;<i)>j)?i:j,相当于是比较cout&lt;<i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。 cout="" <<="" (i="">j)?i:j;//输出1或0，相当于(cout&lt;&lt;(i&gt;j))作为判决条件，来决定表达式的值为i或j，而cout&lt;&lt;(i&gt;j)，i&gt;j则输出1否则0，然后再将(cout&lt;&lt;(i&gt;j))作为？：的条件，如果cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或j<br>cout &lt;&lt;(i&gt;j?i:j);//i&gt;j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false<br>更多的关于优先级的问题就不说了。</i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。></i)></p>
<p>5、语句标签<br>通常跟goto配合使用，如：<br>step1: a = f1();<br>….<br>goto step1;<br>这种作法也不是很推荐，原因在于它破坏了语句的顺序执行，这样的代价大家应该清楚吧。不过存在即为合理嘛，既然它还存在，肯定还是有它的用处有它的好处的，比如说，多层嵌套的退出（会比break continue直观一点吧），也可以避免重复代码之类之类的</p>
<p>6、switch语句中case后。<br>这个不说了，要是不会的话，我也没话可说了。</p>
<p>7、汇编指令模板<br>这个我也不懂，不班门弄斧了，可以参考一下：<a href="http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html" target="_blank" rel="noopener">http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html</a><br>改天学习一下。</p>
<hr>
<hr>
<hr>
<p>1、<br>作用域符号::的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分<br>如：A,B表示两个类，在A,B中都有成员member。那么<br>A::member就表示类A中的成员member<br>B::member就表示类B中的成员member </p>
<p>2、<br>全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分如： </p>
<p>char zhou; //全局变量 </p>
<p>void sleep（） </p>
<p>｛ </p>
<p>char zhou; //局部变量 </p>
<p>char(局部变量) = char(局部变量) *char(局部变量) ; </p>
<p>::char(全局变量) =::char(全局变量) *char(局部变量); </p>
<p>｝ </p>
<p>3、<br>::是C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">01  class CA &#123;    </span><br><span class="line">02  public:    </span><br><span class="line">03    int ca_var;    </span><br><span class="line">04    int add(int a, int b);    </span><br><span class="line">05    int add(int a);    </span><br><span class="line">06  &#125;;   </span><br><span class="line">07      </span><br><span class="line">08  //那么在实现这个函数时，必须这样书写：    </span><br><span class="line">09  int CA::add(int a, int b)    </span><br><span class="line">10  &#123;    </span><br><span class="line">11    return a + b;    </span><br><span class="line">12  &#125;    </span><br><span class="line">13      </span><br><span class="line">14  //另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如:    </span><br><span class="line">15  int CA::add(int a)    </span><br><span class="line">16  &#123;    </span><br><span class="line">17    return a + ::ca_var;    </span><br><span class="line">18  &#125;   </span><br><span class="line">19      </span><br><span class="line">20  //表示当前类实例中的变量ca_var。</span><br></pre></td></tr></table></figure>
<p>转载：<a href="https://blog.csdn.net/zimingjushi/article/details/6549390/" target="_blank" rel="noopener">https://blog.csdn.net/zimingjushi/article/details/6549390/</a></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

