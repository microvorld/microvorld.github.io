<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="damn1t"><meta name="renderer" content="webkit"><meta name="copyright" content="damn1t"><meta name="keywords" content="damn1t"><meta name="description" content="404"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2018-8715 · Mr.Long's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">longlongyu</div><div class="profile-signature">for me</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Long's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2018-8715</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019-05-12</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="cve"> cve</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2018-8715"><a href="#CVE-2018-8715" class="headerlink" title="CVE-2018-8715"></a>CVE-2018-8715</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>利用vulnhub的环境<br><code>docker-compose up -d</code>后台运行，端口设置不要改，默认<code>8080</code></p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="Appweb简介"><a href="#Appweb简介" class="headerlink" title="Appweb简介"></a>Appweb简介</h3><p>Appweb是一个嵌入式HTTP Web服务器，主要的设计思路是安全。这是直接集成到客户的应用和设备，便于开发和部署基于Web的应用程序和设备。它迅速（ 每秒处理3500多要求）而紧凑 ，其中包括支持动态网页制作，服务器端嵌入式脚本过程中的CGI ，可加载模块的SSL ，摘要式身份验证，虚拟主机， Apache样式配置，日志记录，单和多线程应用程序。它提供了大量的文档和示例。</p>
<p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p>
<p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p>
<ul>
<li>basic 传统HTTP基础认证</li>
<li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li>
<li>form 表单认证</li>
</ul>
<h3 id="漏洞原理及复现"><a href="#漏洞原理及复现" class="headerlink" title="漏洞原理及复现"></a>漏洞原理及复现</h3><p>我复现的时候并没有如他人所说需要重置<code>session</code>，直接添加：<code>Authorization: Digest username=joshua</code><br><img src="https://i.loli.net/2019/05/11/5cd6eb191bdb6.png" alt=""></p>
<p>正常步骤是：<br>在添加了<code>Authorization: Digest username=joshua</code>之后，因为我们没有传入密码字段，所以服务端出现错误，直接返回了<code>200</code>，且包含一个<code>session</code>，于是再附上<code>session</code>：<br><img src="https://img-blog.csdnimg.cn/20190212222013874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkzNjU2Ng==,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参<br>数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p>
<p>漏洞位置在<a href="https://github.com/embedthis/appweb/blob/v7.0.2/paks/http/dist/httpLib.c" target="_blank" rel="noopener">appweb/paks/http/dist/httpLib.c</a></p>
<p>首先是<code>function authCondition()</code></p>
<pre><code>/*
    This condition is used to implement all user authentication for routes
 */
static int authCondition(HttpConn *conn, HttpRoute *route, HttpRouteOp *op)
{
    HttpAuth    *auth;
    cchar       *username, *password;

    assert(conn);
    assert(route);

    auth = route-&gt;auth;
    if (!auth || !auth-&gt;type) {
        /* Authentication not required */
        return HTTP_ROUTE_OK;
    }
    if (!httpIsAuthenticated(conn)) {
        httpGetCredentials(conn, &amp;username, &amp;password);
        if (!httpLogin(conn, username, password)) {
            if (!conn-&gt;tx-&gt;finalized) {
                if (auth &amp;&amp; auth-&gt;type) {
                    (auth-&gt;type-&gt;askLogin)(conn);
                } else {
                    httpError(conn, HTTP_CODE_UNAUTHORIZED, &quot;Access Denied, login required&quot;);
                }
                /* Request has been denied and a response generated. So OK to accept this route. */
            }
            return HTTP_ROUTE_OK;
        }
    }
    if (!httpCanUser(conn, NULL)) {
        httpTrace(conn, &quot;auth.check&quot;, &quot;error&quot;, &quot;msg:&#39;Access denied, user is not authorized for access&#39;&quot;);
        if (!conn-&gt;tx-&gt;finalized) {
            httpError(conn, HTTP_CODE_FORBIDDEN, &quot;Access denied. User is not authorized for access.&quot;);
            /* Request has been denied and a response generated. So OK to accept this route. */
        }
    }
    /* OK to accept route. This does not mean the request was authenticated - an error may have been already generated */
    return HTTP_ROUTE_OK;
}
</code></pre><p>这个函数负责调用两个用于认证处理的函数：<code>getCredentials</code>和<code>httpLogin</code>，注意到<code>httpGetCredentials</code>周围缺少检查，这将会在稍后起到作用</p>
<p><code>httpGetCredentials()</code>:</p>
<pre><code>/*
    Get the username and password credentials. If using an in-protocol auth scheme like basic|digest, the
    rx-&gt;authDetails will contain the credentials and the parseAuth callback will be invoked to parse.
    Otherwise, it is expected that &quot;username&quot; and &quot;password&quot; fields are present in the request parameters.
    This is called by authCondition which thereafter calls httpLogin
 */
PUBLIC bool httpGetCredentials(HttpConn *conn, cchar **username, cchar **password)
{
    HttpAuth    *auth;

    assert(username);
    assert(password);
    *username = *password = NULL;

    auth = conn-&gt;rx-&gt;route-&gt;auth;
    if (!auth || !auth-&gt;type) {
        return 0;
    }
    if (auth-&gt;type) {
        if (conn-&gt;authType &amp;&amp; !smatch(conn-&gt;authType, auth-&gt;type-&gt;name)) {
            if (!(smatch(auth-&gt;type-&gt;name, &quot;form&quot;) &amp;&amp; conn-&gt;rx-&gt;flags &amp; HTTP_POST)) {
                /* If a posted form authentication, ignore any basic|digest details in request */
                return 0;
            }
        }
        if (auth-&gt;type-&gt;parseAuth &amp;&amp; (auth-&gt;type-&gt;parseAuth)(conn, username, password) &lt; 0) {
            return 0;
        }
    } else {
        *username = httpGetParam(conn, &quot;username&quot;, 0);
        *password = httpGetParam(conn, &quot;password&quot;, 0);
    }
    return 1;
}
</code></pre><p>该函数接收两个指向数组的指针用于从请求中解析<code>username</code>和<code>password</code>。既然<code>authCondition</code>没有进行参数检查，那么<code>parseAuth</code>失败也无关紧要。这意味着我们能够插入<code>WWW-Authenticate header</code>或者post任何我们想要的认证数据</p>
<p><code>httpLogin()</code>：</p>
<pre><code>/*
    Login the user and create an authenticated session state store
 */
PUBLIC bool httpLogin(HttpConn *conn, cchar *username, cchar *password)
{
    HttpRx          *rx;
    HttpAuth        *auth;
    HttpSession     *session;
    HttpVerifyUser  verifyUser;

    rx = conn-&gt;rx;
    auth = rx-&gt;route-&gt;auth;
    if (!username || !*username) {
        httpTrace(conn, &quot;auth.login.error&quot;, &quot;error&quot;, &quot;msg:&#39;missing username&#39;&quot;);
        return 0;
    }
    if (!auth-&gt;store) {
        mprLog(&quot;error http auth&quot;, 0, &quot;No AuthStore defined&quot;);
        return 0;
    }
    if ((verifyUser = auth-&gt;verifyUser) == 0) {
        if (!auth-&gt;parent || (verifyUser = auth-&gt;parent-&gt;verifyUser) == 0) {
            verifyUser = auth-&gt;store-&gt;verifyUser;
        }
    }
    if (!verifyUser) {
        mprLog(&quot;error http auth&quot;, 0, &quot;No user verification routine defined on route %s&quot;, rx-&gt;route-&gt;pattern);
        return 0;
    }
    if (auth-&gt;username &amp;&amp; *auth-&gt;username) {
        /* If using auto-login, replace the username */
        username = auth-&gt;username;
        password = 0;
    }
    if (!(verifyUser)(conn, username, password)) {
        return 0;
    }
    if (!(auth-&gt;flags &amp; HTTP_AUTH_NO_SESSION) &amp;&amp; !auth-&gt;store-&gt;noSession) {
        if ((session = httpCreateSession(conn)) == 0) {
            /* Too many sessions */
            return 0;
        }
        httpSetSessionVar(conn, HTTP_SESSION_USERNAME, username);
        httpSetSessionVar(conn, HTTP_SESSION_IP, conn-&gt;ip);
    }
    rx-&gt;authenticated = 1;
    rx-&gt;authenticateProbed = 1;
    conn-&gt;username = sclone(username);
    conn-&gt;encoded = 0;
    return 1;
}
</code></pre><p>这一函数会检查username是否为空，当session已被分配时，<code>password</code>指针可以为空</p>
<p>为了能够绕过身份验证，我们需要能够传递空密码指针，幸运的是，对于表单和摘要身份验证，用于解析身份验证详细信息的函数（第1666行）将允许我们设置空密码指针，并且即使返回错误，最终也不会被authCondition检查，允许我们完全绕过身份验证，利用这个的唯一条件是知道hashmap中的用户名。</p>
<p>为了克服这个限制，必须考虑到散列映射的大小通常很小，并且散列映射中使用的散列算法（FNV）很弱：尝试次数有限，可能会发现冲突，并且登录不知道有效的用户名（未经测试）</p>
<p>reference：<br><a href="https://blog.csdn.net/weixin_42936566/article/details/87120710" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42936566/article/details/87120710</a><br><a href="https://ssd-disclosure.com/archives/3676" target="_blank" rel="noopener">https://ssd-disclosure.com/archives/3676</a><br><a href="https://github.com/embedthis/appweb/issues/610" target="_blank" rel="noopener">https://github.com/embedthis/appweb/issues/610</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://microvorld.com">damn1t</a></p><p> <span>Link:  </span><a href="http://microvorld.com/2019/05/12/cve/CVE-2018-8715/">http://microvorld.com/2019/05/12/cve/CVE-2018-8715/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/05/20/web/Code-Breaking Puzzles/" title="Code-Breaking Puzzles"><span>< PreviousPost</span><br><span class="prevTitle">Code-Breaking Puzzles</span></a><a class="nextSlogan" href="/2019/05/09/vulnerable/intigriti xss challenge/" title="Intigriti XSS Challenge - Solution and problem solving approach"><span>NextPost ></span><br><span class="nextTitle">Intigriti XSS Challenge - Solution and problem solving approach</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2018-8715"><span class="toc-number">1.</span> <span class="toc-text">CVE-2018-8715</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#环境搭建"><span class="toc-number">1.1.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复现"><span class="toc-number">1.2.</span> <span class="toc-text">复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Appweb简介"><span class="toc-number">1.2.1.</span> <span class="toc-text">Appweb简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞原理及复现"><span class="toc-number">1.2.2.</span> <span class="toc-text">漏洞原理及复现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">1.3.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>