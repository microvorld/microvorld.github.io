<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>关于编码与解码的思考 | </title>

  
  <meta name="author" content="damn1t">
  

  
  <meta name="description" content="关于编码与解码的思考最近做了SCTF，看了官方wp，其中看到了在进行xss测试的使用了
{{&#39;a&#39;.constructor.prototype.charAt=[].join;$eval(&#39;x=1} }
    };\u0061\u006c\u0065\u0072\u0074\u0028\u0031\">
  

  
  
  <meta name="keywords" content="web">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="关于编码与解码的思考"/>

  <meta property="og:site_name" content=""/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/"></a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>关于编码与解码的思考</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/19/web/编码与解码/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-18T17:32:30.996Z">
          2018-07-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="关于编码与解码的思考"><a href="#关于编码与解码的思考" class="headerlink" title="关于编码与解码的思考"></a>关于编码与解码的思考</h1><p>最近做了SCTF，看了官方wp，其中看到了在进行xss测试的使用了</p>
<pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} }
    };\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029//');}}
</code></pre><p>这时不禁想到了一个问题，为什么要进行js编码？什么时候才应该进行编码绕过？浏览器与服务器之间是如何处理编码与解码的？</p>
<h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong><a href="http://www.w3school.com.cn/tags/html_ref_urlencode.html" target="_blank" rel="noopener">URL编码</a></strong>：一个百分号和该字符的ASCII编码所对应的2位十六进制数字，例如“/”的URL编码为%2F(一般大写，但不强求)<br><strong><a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">HTML实体编码</a></strong>：<br><strong>命名实体</strong>：以&amp;开头，分号结尾的，例如“<code>&lt;</code>”的编码是”<code>&amp;lt;</code>“<br><strong>字符编码</strong>：十进制、十六进制ASCII码或unicode字符编码，样式为“&amp;#数值;”,例如“&lt;”可以编码为“<code>&amp;#060;</code>”和“<code>&amp;#x3c;</code>”<br><strong>JS编码</strong>：js提供了四种字符编码的策略</p>
<pre><code>1、三个八进制数字，如果不够个数，前面补0，例如&quot;e&quot;编码为&quot;\145&quot;
2、两个十六进制数字，如果不够个数，前面补0，例如&quot;e&quot;编码为&quot;\x65&quot;
3、四个十六进制数字，如果不够个数，前面补0，例如&quot;e&quot;编码为&quot;\u0065&quot;
4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）
</code></pre><p><strong>CSS编码</strong>：用一个反斜线()后面跟1~6位的十六进制数字，例如e可以编码为”\65”或”65”或”00065”<br><strong>复合编码</strong>：<br>所谓复合编码，也就是说输出的内容输出在多个环境中，例如</p>
<pre><code>&lt;td onclick=&quot;openUrl(add.do?userName=&apos;&lt;%=value%&gt;&apos;);&quot;&gt;11&lt;/td&gt;
</code></pre><p>value的内容首先出现在一个URL中，这个URL在一段javascript总，而javascript代码又是html的一部分。所以解码的顺序就是HTML解码–&gt;js解码–&gt;url解码，那么正确的编码顺序就应该是url编码–&gt;js编码–&gt;html编码。<br>下面的代码参考了文章：<a href="http://www.freebuf.com/articles/web/43285.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/43285.html</a></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>核心代码：</p>
<pre><code>&lt;?php

function htmlencode($str){
   if(empty($str)) return;
   if($str == &quot;&quot;) return;

   $str = str_ireplace(&quot;&lt;&quot;,&quot;&quot;,$str);
   $str = str_ireplace(&quot;&gt;&quot;,&quot;&quot;,$str);
   $str = str_ireplace(&quot;script&quot;,&quot;&quot;,$str);
   $str = str_ireplace(&quot;img&quot;,&quot;&quot;,$str);
   $str = str_ireplace(&quot;:&quot;,&quot;&quot;,$str);
   $str = str_ireplace(&quot;javascript&quot;,&quot;&quot;,$str);

   return $str;
}

if(!array_key_exists (&quot;name&quot;,$_GET) || $_GET[&apos;name&apos;] == NULL || $_GET[&apos;name&apos;] == &apos;&apos;){

 $isempty = true;

} else {

 $html .= &apos;&lt;pre&gt;&apos;;
 $html .= &apos;&lt;a onclick=&quot;&apos;.htmlencode($_GET[&apos;name&apos;]).&apos;&quot;&gt;click this url&lt;/a&gt;&apos;;
 $html .= &apos;&lt;/pre&gt;&apos;;

}
echo $html;
?&gt;
</code></pre><p>对用户输入进行了过滤操作，过滤了：&lt;，&gt;，script，等，这里还要提一下<code>&lt;pre&gt;</code>标签:</p>
<blockquote>
<p>pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p>
</blockquote>
<p>也就是说，原封不动应用原格式而不会进行html的预处理更改<br>然后考虑如何注入xss，$name存在于两层环境中，先在html中，然后在js中，所以解码的顺序是html-&gt;js,因此可以构造<code>javascript:alert(/xss/)</code>，然后这里可以对整个语句进行html编码：</p>
<pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#47;&amp;#41;
</code></pre><p>或者局部编码：</p>
<pre><code>java&amp;#115;cript&amp;#58;alert(/xss/)
</code></pre><p>都可以得到结果：<br><img src="https://i.imgur.com/bvG7IU9.png" alt=""></p>
<h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><p>主要代码：</p>
<pre><code>&lt;?php

if(!array_key_exists (&quot;name&quot;,$_GET) || $_GET[&apos;name&apos;] == NULL || $_GET[&apos;name&apos;] == &apos;&apos;){

   $isempty = true;

} else {
   $value = $_GET[&apos;name&apos;];
   $html .= &apos;&lt;pre&gt;&apos;;
   $html .= &quot;Your Name is :
   &lt;div id=&apos;a&apos;&gt;&lt;/div&gt;
   &lt;script&gt;
   document.getElementById(&apos;a&apos;).innerHTML= &quot;.&quot;&apos;&quot;.htmlspecialchars($value).&quot;&apos;&quot;.&quot;;
   &lt;/script&gt;
 &quot;;
   $html .= &apos;&lt;/pre&gt;&apos;;

}

echo $html;
?&gt;
</code></pre><p>当我们输入<code>&lt;img src=1 onerror=alert(1)&gt;</code>时，可以发现源代码已将其处理为<br><img src="https://i.imgur.com/wuu389H.png" alt=""><br>因为<code>htmlspecialchars</code>对特殊字符进行了处理，会将”&lt;”，”&gt;”，”&amp;”，” ‘ “，” “ “处理为实体，所以再分析$value所处的环境，因为处在<code>&lt;scritpt&gt;</code>中，所以先是js环境，然后是html环境，所以可以对其进行js编码：</p>
<pre><code>\x3c\x69\x6d\x67\x20\x73\x72\x63\x3d\x31\x20\x6f\x6e\x65\x72\x72\x6f\x72\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e
</code></pre><p>得到弹窗<br><img src="https://i.imgur.com/ZDAZnS2.png" alt=""></p>
<h2 id="如何理解编码与解码过程"><a href="#如何理解编码与解码过程" class="headerlink" title="如何理解编码与解码过程"></a>如何理解编码与解码过程</h2><p>其实我当时看了还是有点绕，最后查了下资料，大致总结下：</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>首先要理解的是DOM这个东西，<strong>文档对象模型</strong>，DOM是现目前而言处理html和xml的常用方法，给个图：<br><img src="https://i.imgur.com/7vSjUUg.jpg" alt=""><br>当处理html文档的时候，他就会将其肢解为一个个的分支树，然后解析</p>
<h3 id="浏览器基本工作流程"><a href="#浏览器基本工作流程" class="headerlink" title="浏览器基本工作流程"></a>浏览器基本工作流程</h3><h4 id="浏览器的构成"><a href="#浏览器的构成" class="headerlink" title="浏览器的构成"></a>浏览器的构成</h4><ul>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
</ul>
<ul>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
</ul>
<ul>
<li>渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li>
</ul>
<ul>
<li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li>
</ul>
<ul>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
</ul>
<ul>
<li>JS解释器－ 用来解释执行JS代码</li>
</ul>
<ul>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<p><img src="https://i.imgur.com/sAUHYh0.jpg" alt=""></p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://i.imgur.com/t23zz6c.jpg" alt=""></p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><blockquote>
<ol>
<li><p>当浏览器发送http请求时，会先对特殊字符进行URL编码后，发送给服务器。</p>
</li>
<li><p>服务器收到客户端发送来的http请求，会对其进行URL解码后，再进行处理，处理完成后将结果返回给浏览器。</p>
</li>
<li>浏览器接收到html文件后，最先是触发html解析器来解析html，将标签转化为内容树中的DOM节点，此时在识别标签的时候，html解析器是不能识别哪些被html实体编码了，只有当整个DOM树建立起来后，才能对每个节点的内容进行识别，如果有html实体编码，再对其进行解码。</li>
<li>在html解析器过程中，遇到js标签诸如<code>&lt;script&gt;</code>会调用js解释器对js代码进行解析，而js DOM API会对DOM结构进行更改，DOM树节点的更改也会反过来触发html解释器。</li>
<li>CSS解释器也会在html解释器过程中参与进来，但它不会干扰到DOM树，它会结合<code>&lt;style&gt;</code>标签和CSS文件以及html指令来构建render tree。</li>
</ol>
</blockquote>
<p>概括言之：<br><strong>URL解析-&gt;HTML解析-&gt;css渲染-&gt;js解析</strong><br>DOM树有特定语法规则，识别特定标签，这意味着，如果标签被破坏，DOM则会置之不理<br>回顾之前两个例子：</p>
<ul>
<li>第一个场景中，js语句是在a标签中，在onclick事件触发js解释器之前，DOM树结构已经建立完成了，并且这里也没有DOM API操作，所以浏览器会先对该语句进行html解码，然后再是js解码，所以当我们对payload进行html编码后，在js解释器解析该js语句时，其已经被html解码了，是正常的js语句，所以能够正常弹窗。</li>
</ul>
<ul>
<li>场景二中，payload是在script标签里面，浏览器解析到这里时，会触发js解释器，js解释器会对该语句进行js解码操作，我们使用js编码的payload被还原成正常的语句。虽然此时整个DOM树已经建立起来了，但是由于DOM API存在，会再一次的调用html解释器，对我们的payload进行解析，payload里面有js标签，再一次触发js解释器，完成对js语句调用，成功弹窗。</li>
</ul>
<p>参考链接：<br><a href="http://www.mamicode.com/info-detail-1712225.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1712225.html</a><br><a href="http://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">http://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/web/">web</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 damn1t
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>